#include <iomanip>
#include <iostream>

int main() {
    // Ініціалізація масиву з 25 цілих чисел
    int arr[25] = { -7, -5, -5, 0, -3, 3, 3, -1, 3, -8, 9, 4, -6, 7, 9, 1, 3, -5, 2, 8, 8, -1, -4, 1, -3 };
    int n = 5, m = 5; // Розміри матриці 5x5
    int sum, res; // Змінні для зберігання суми та результату множення

    __asm {
        pushad             // Зберігаємо всі регістри на стек
        xor ebx, ebx       // Очищаємо регістр ebx
        xor edx, edx       // Очищаємо регістр edx (буде використовуватися для підрахунку суми)
        mov eax, 1         // Ініціалізуємо регістр eax одиницею (для множення)
        lea esi, arr       // Завантажуємо адресу масиву arr в регістр esi
        mov ecx, n         // Встановлюємо лічильник циклу для рядків

        _n_loop :
            push ecx           // Зберігаємо поточне значення лічильника рядків на стек
            mov ecx, m         // Встановлюємо лічильник циклу для стовпців

        _m_loop :
            push esi           // Зберігаємо поточне значення регістра esi на стек
            cmp[esi], 0       // Порівнюємо поточний елемент масиву зі значенням 0
            jl _lower          // Якщо елемент менше 0, переходимо до мітки _lower
            jmp _step          // Інакше переходимо до мітки _step

        _lower :
            add edx, [esi]     // Додаємо значення від'ємного елемента до суми в edx
            imul eax, [esi]    // Множимо поточне значення результату на від'ємний елемент
            jmp _step          // Переходимо до мітки _step

        _step :
            pop esi            // Відновлюємо значення регістра esi зі стеку
            add esi, 4         // Переходимо до наступного елемента масиву (ціле число займає 4 байти)
            loop _m_loop       // Зменшуємо значення ecx і переходимо до мітки _m_loop, якщо ecx не дорівнює нулю
            pop ecx            // Відновлюємо значення лічильника рядків зі стеку
            loop _n_loop       // Зменшуємо значення ecx і переходимо до мітки _n_loop, якщо ecx не дорівнює нулю

        mov sum, edx       // Зберігаємо результат суми від'ємних елементів в змінну sum
        mov res, eax       // Зберігаємо результат множення в змінну res
        popad              // Відновлюємо значення всіх регістрів зі стеку
    }

    // Виводимо масив на екран у вигляді матриці 5x5
    std::cout << "Array: \n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cout << std::setw(4) << arr[i * n + j] << " ";
        }
        std::cout << std::endl;
    }

    // Виводимо результати обчислень
    std::cout << "\nSum = " << sum; // Виводимо суму від'ємних елементів
    std::cout << "\nResult = " << res; // Виводимо результат множення від'ємних елементів
    return 0;
}
